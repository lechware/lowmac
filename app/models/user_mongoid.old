class User < ActiveRecord::Base

  # Used to store the currently logged in user.
  cattr_accessor :current

  # include Mongoid::Document
  # include Mongoid::Timestamps

  #
  # Callbacks
  # 
  before_save :ensure_authentication_token

  #
  # Relations
  #
  belongs_to :account
  
  # has_one :profile #, cascade_callbacks: true
  # accepts_nested_attributes_for :profile


  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable



  # #
  # # Fields
  # # 

  # field :role, type: String, default: 'admin'

  # ## Database authenticatable
  # field :email,              type: String, default: ""
  # field :name,               type: String, default: ""
  # field :encrypted_password, type: String, default: ""
  # field :authentication_token, type: String, default: ""

  # ## Recoverable
  # field :reset_password_token,   type: String
  # field :reset_password_sent_at, type: Time

  # ## Rememberable
  # field :remember_created_at, type: Time

  # ## Trackable
  # field :sign_in_count,      type: Integer, default: 0
  # field :current_sign_in_at, type: Time
  # field :last_sign_in_at,    type: Time
  # field :current_sign_in_ip, type: String
  # field :last_sign_in_ip,    type: String

  # ## Confirmable
  # # field :confirmation_token,   type: String
  # # field :confirmed_at,         type: Time
  # # field :confirmation_sent_at, type: Time
  # # field :unconfirmed_email,    type: String # Only if using reconfirmable

  # ## Lockable
  # # field :failed_attempts, type: Integer, default: 0 # Only if lock strategy is :failed_attempts
  # # field :unlock_token,    type: String # Only if unlock strategy is :email or :both
  # # field :locked_at,       type: Time

  # Validations
  validates :name, :email, :account, :role, presence: true
  validates :email, uniqueness: {scope: :account}

  # Scope
  scope :staff, ->{ where(role: 'staff') } 
  scope :by_account, ->(account){ where(account: account) } 

  def to_s
    self.name.titleize
  end

  def is?( requested_role)
    role == requested_role.to_s
  end

  def ensure_authentication_token
    if authentication_token.blank?
      authentication_token = generate_authentication_token
    end
  end

  # FIXME: https://github.com/plataformatec/devise/issues/2949 - Remove below once fix has been shipped
  # UPDATE: Apparently issue seems to be fixed, but leaving here for reference.
  # class << self
    # def serialize_from_session(key,salt)
    #   logger.info "Session Serialization: key,salt - #{key} #{salt}"
    #   record = to_adapter.get(key[0]["$oid"])
    #   logger.info "Session Serialization: Record - #{record}"
    #   record if record && record.authenticatable_salt == salt
    # end

    # def serialize_from_cookie(key,salt)
    #   logger.info "Cookie Serialization: key,salt - #{key} #{salt}"
    #   record = to_adapter.get(key[0]["$oid"])
    #   logger.info "Cookie Serialization: Record - #{record}"
    #   record if record && record.authenticatable_salt == salt
    # end
  # end
  
  private
  def generate_authentication_token
    loop do
      token = Devise.friendly_token
      break token unless User.where(authentication_token: token).first
    end
  end
end
